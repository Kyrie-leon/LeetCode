# NC78 反转链表

## 描述

输入一个链表，反转链表后，输出新链表的表头。

## 示例1

输入：

```
{1,2,3}
```

复制

返回值：

```
{3,2,1}
```

思路1：

正序遍历链表入栈，栈中链表依次出栈，也可以用vector存放

时间复杂度O(n)

空间复杂度O(n)

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == nullptr)
            return nullptr;
        stack<ListNode*> st;
        ListNode* cur = pHead;
        //1.第一遍遍历所有节点入栈
        while(cur)
        {
            st.push(cur);
            cur = cur->next;
        }
        //2.反转链表
        pHead = st.top();
        st.pop();
        cur = pHead;
        while(!st.empty())
        {
            cur->next = st.top();
            cur = cur->next;
            st.pop();
        }
        //最后一个节点的next置null
        cur->next = nullptr;
        return pHead;
    }
};
```

思路2：

# [JZ3 从尾到头打印链表][https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035]

## 描述

输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。

## 示例1

输入：

```
{1,2,3}
```

复制

返回值：

```
[3,2,1]
```

复制

## 示例2

输入：

```
{67,0,24,58}
```

复制

返回值：

```
[58,24,0,67]
```

思路1：

遍历链表存入数组，数组再逆置

```c++
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> ret;
        while(head)
        {
            ret.push_back(head->val);
            head = head->next;
        }
        reverse(ret.begin(), ret.end());
        return ret;
    }
};
```

思路2：

递归，类似于二叉树遍历

```c++
class Solution {
public:
    vector<int> _printListFromTailToHead(ListNode* head, vector<int>& ret)
    {
        if(head == nullptr)
            return ret;
        ret = _printListFromTailToHead(head->next, ret);
        ret.push_back(head->val);
        return ret;
    }
    
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> ret;
        ret = _printListFromTailToHead(head, ret);
        return ret;
    }
};
```

思路3:

链表反转

```c++
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        ListNode *prev = nullptr;
        ListNode *cur = head;
        ListNode *next = cur->next;
        //反转链表
        while(cur)
        {
            next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }
        //遍历链表存储链表值
        vector<int> ret;
        head = prev;    //头结点已经变了
        while(head)
        {
            ret.push_back(head->val);
            head = head->next;
        }
        return ret;
    }
};
```

