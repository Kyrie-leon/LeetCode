# NC78 反转链表

## 描述

输入一个链表，反转链表后，输出新链表的表头。

## 示例1

输入：

```
{1,2,3}
```

返回值：

```
{3,2,1}
```

思路1：

正序遍历链表入栈，栈中链表依次出栈，也可以用vector存放

时间复杂度O(n)

空间复杂度O(n)

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == nullptr)
            return nullptr;
        stack<ListNode*> st;
        ListNode* cur = pHead;
        //1.第一遍遍历所有节点入栈
        while(cur)
        {
            st.push(cur);
            cur = cur->next;
        }
        //2.反转链表
        pHead = st.top();
        st.pop();
        cur = pHead;
        while(!st.empty())
        {
            cur->next = st.top();
            cur = cur->next;
            st.pop();
        }
        //最后一个节点的next置null
        cur->next = nullptr;
        return pHead;
    }
};
```

思路2：三个指针逆置链表

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == nullptr)
            return nullptr;
        ListNode* prev = nullptr;
        ListNode* cur = pHead;
        ListNode* next = cur->next;
        //遍历链表逆置
        while(cur)
        {
            next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }
        
        return prev;
    }
};
```

# [JZ3 从尾到头打印链表][https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035]

## 描述

输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。

## 示例1

输入：

```
{1,2,3}
```

返回值：

```
[3,2,1]
```

## 示例2

输入：

```
{67,0,24,58}
```

返回值：

```
[58,24,0,67]
```

思路1：

遍历链表存入数组，数组再逆置

```c++
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> ret;
        while(head)
        {
            ret.push_back(head->val);
            head = head->next;
        }
        reverse(ret.begin(), ret.end());
        return ret;
    }
};
```

思路2：

递归，类似于二叉树遍历

```c++
class Solution {
public:
    vector<int> _printListFromTailToHead(ListNode* head, vector<int>& ret)
    {
        if(head == nullptr)
            return ret;
        ret = _printListFromTailToHead(head->next, ret);
        ret.push_back(head->val);
        return ret;
    }
    
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> ret;
        ret = _printListFromTailToHead(head, ret);
        return ret;
    }
};
```

思路3:

链表反转

```c++
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        ListNode *prev = nullptr;
        ListNode *cur = head;
        ListNode *next = cur->next;
        //反转链表
        while(cur)
        {
            next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }
        //遍历链表存储链表值
        vector<int> ret;
        head = prev;    //头结点已经变了
        while(head)
        {
            ret.push_back(head->val);
            head = head->next;
        }
        return ret;
    }
};
```

# [JZ14 链表中倒数最后k个结点][https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9]

## 描述

输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。

如果该链表长度小于k，请返回一个长度为 0 的链表。

## 示例1

输入：

```
{1,2,3,4,5},1 
```

返回值：

```
{5}
```

思路：

快慢指针，想让快指针真走k步，然后快慢指针一起走，当快指针走完返回慢指针即可

细节：

1. 如果k大于链表长度，快指针还没走完k步就已经指向空，因此走k步的循环里需要判断快指针是否为空，如果为空直接返回

```c++
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 *	ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pHead, int k) {
        ListNode* slow = pHead;
        ListNode* fast = pHead;
        //先让快指针走k步
        while(k--)
        {
            if(fast)
                fast = fast->next;
            else
                return nullptr;
        }
        //双指针一起走
        while(fast)
        {
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

# [**JZ16** **合并两个排序的链表**][https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337]

## 描述

输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

## 示例1

输入：

```
{1,3,5},{2,4,6}
```

返回值：

```
{1,2,3,4,5,6}
```

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
            //给一个头结点
            ListNode* pHead = new ListNode(-1);
            ListNode* cur = pHead;
            //遍历链表
            while(pHead1 && pHead2)
            {
                if(pHead1->val <= pHead2->val)
                {
                    cur->next = pHead1;
                    pHead1 = pHead1->next;
                }
                else
                {
                    cur->next = pHead2;
                    pHead2 = pHead2->next;
                }
                cur = cur->next;
            }
            //把没完的链表链接到后面
            cur->next = pHead1 ? pHead1 : pHead2;
            return pHead->next;
    }
};
```

# [**JZ25** **复杂链表的复制**][https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba]

## 描述

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 下图是一个含有5个结点的复杂链表。图中实线箭头表示next指针，虚线箭头表示random指针。为简单起见，指向null的指针没有画出。

## 示例1

输入：

```
{1,2,3,4,5,3,5,#,2,#}
```

复制

返回值：

```
{1,2,3,4,5,3,5,#,2,#}
```

思路1：

时间空间复杂度O(n)

用一个map存储旧结点和新结点的指针

第一遍遍历旧结点

```c++
/*
struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
};
*/
class Solution {
public:
    RandomListNode* Clone(RandomListNode* pHead) {
        //map保存原来的节点和新节点
        map<RandomListNode*, RandomListNode*> ncMap;
        RandomListNode* cur = pHead;
        //原链表节点保存到map并复制新节点
        while(cur)
        {
            ncMap[cur] = new RandomListNode(cur->label);
            cur = cur->next;
        }
        //将新节点连接起来
        cur = pHead;
        while(cur)
        {
            ncMap[cur]->next = ncMap[cur->next];
            ncMap[cur]->random = ncMap[cur->random];
            cur = cur->next;
        }
        RandomListNode* newHead = ncMap[pHead];
        return newHead;
    }
};
```

# [**JZ36** **两个链表的第一个公共结点**][https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&&tqId=11189&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking]

输入两个无环的单链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

## 示例1

输入：

```
{1,2,3},{4,5},{6,7}
```

复制

返回值：

```
{6,7}
```

复制

说明：

```
第一个参数{1,2,3}代表是第一个链表非公共部分，第二个参数{4,5}代表是第二个链表非公共部分，最后的{6,7}表示的是2个链表的公共部分
这3个参数最后在后台会组装成为2个两个无环的单链表，且是有公共节点的     
```

## 示例2

输入：

```
{1},{2,3},{}
```

复制

返回值：

```
{}
```

复制

说明：

```
2个链表没有公共节点 ,返回null，后台打印{}  
```

思路：

双指针法，先分别遍历两个两个链表求出每个链表的长度，让长链表先走一个差值步，然后两个链表同时走，当两个链表指针相同则返回，如果都走完没有交点，返回nullptr

```c++
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/

class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        int len1 = 0;
        int len2 = 0;
        ListNode* cur1 = pHead1;
        ListNode* cur2 = pHead2;
        while(cur1)
        {
            len1++;
            cur1 = cur1->next;
        }
        while(cur2)
        {
            len2++;
            cur2 = cur2->next;
        }
        cur1 = pHead1;
        cur2 = pHead2;
        int k = 0;
        if(len1 > len2)
        {
            k = len1 - len2;
            while(k--)
            {
                cur1 = cur1->next;
            }
        }
        if(len1 < len2)
        {
            k = len2 - len1;
            while(k--)
            {
                cur2 = cur2->next;
            }
        }
        
        while(cur1 && cur2)
        {
            if(cur1 == cur2)
                return cur1;
            cur1 = cur1->next;
            cur2 = cur2->next;
        }
        
        return nullptr;
    }
};
```

# [**JZ55** **链表中环的入口结点**][https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4]

## 描述

给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。

### 输入描述：

输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台将这2个会组装成一个有环或者无环单链表

### 返回值描述：

返回链表的环的入口结点即可。而我们后台程序会打印这个节点

## 示例1

输入：

```
{1,2},{3,4,5}
```

复制

返回值：

```
3
```

复制

说明：

```
返回环形链表入口节点，我们后台会打印该环形链表入口节点，即3    
```

## 示例2

输入：

```
{1},{}
```

复制

返回值：

```
"null"
```

复制

说明：

```
没有环，返回null，后台打印"null" 
```

## 示例3

输入：

```
{},{2}
```

复制

返回值：

```
2
```

复制

说明：

```
只有环形链表节点2，返回节点2，后台打印2   
```

思路1：

1. 遍历链表存在set里
2. 当发现set里有重复的链表节点时，该节点就是环入口
3. 遍历完没有找到，返回空

时间空间复杂度都是O(N)

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        unordered_set<ListNode*>  nSet;
        ListNode* cur = pHead;
        while(cur)
        {
            if(nSet.find(cur) != nSet.end())
            {
                return cur;
            }
            else
            {
                nSet.insert(cur);
            }
            cur = cur->next;
        }
        
        return nullptr;
    }
};
```

# [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2:

输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.

## 思路：

双指针，一个prev，一个cur

1. 如果删除的是头结点，直接返回head->next;
2. 如果不是就让cur从第二个结点开始遍历，直到找到删除的结点，重新链接关系

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */;

class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        if(head->val == val)
        {
            return head->next;
        }
        ListNode* prev = head;
        ListNode* cur = head->next;
        while(cur != nullptr && cur->val != val)
        {
            prev = cur;
            cur = cur->next;
        }
        if(cur != nullptr)
        {
            prev->next = cur->next;
        }
        return head;
    }
};
```

# [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

难度中等246

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

 

示例 1：



输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
示例 2：



输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
示例 3：



输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
示例 4：

输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null

## 思路

最开始直接剔除空链表

1. 首先在每个结点后面复制一个结点

2. 重新遍历链表将复制的结点的随即指针指向原节点随机结点的后面你个结点

   注意：有可能random为随即指针，加一个if判断不为空才赋值

3. 拆分节点，原节点的第二个结点就是新节点的head

   注意：设两个指针，一个prev指向原来的结点，一个cur指向复制的结点

   循环终止条件不能用cur，因为会存在null指针，用cur->next做判断

   最后cur会到最后一个结点，这时候让prev即原结点链接到空指针即可

```
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head == nullptr)
            return head;
        Node* cur = head;
        //1.第一遍每个结点后边复制一个结点
        while(cur != nullptr)
        {
            Node* copy = new Node(cur->val);
            copy->next = cur->next;
            cur->next = copy;
            cur = copy->next;
        }
        //2.复制random结点
        cur = head;
        while(cur != nullptr)
        {
            if(cur->random != nullptr)
            {
                cur->next->random = cur->random->next;
            }
            cur = cur->next->next;
        }
        //3.断开结点,重新链接
        Node* newHead = head->next;
        Node* prev = head;
        cur = newHead;
        while(cur->next != nullptr)
        {
            prev->next = cur->next;
            prev = prev->next;
            cur->next = cur->next->next;
            cur = cur->next;
        }

        prev->next = nullptr;

        return newHead;
    }
};
```

