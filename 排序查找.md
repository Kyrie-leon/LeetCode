# 二分查找

## 问题描述

[剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一个旋转，该数组的最小值为1。 

**示例 1：**

```
输入：[3,4,5,1,2]
输出：1
```

**示例 2：**

```
输入：[2,2,2,0,1]
输出：0
```

### 解题思路
这道题如果使用二分查找可以将线性遍历O(n)的时间复杂度降低至$O(log_2N)$
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/6214086412edf88424c4dfc521e0ec99.png#pic_center)
观察上图可以看出，旋转数组可以看成两个递增的子数组，而旋转点就是二分查找的中间点
我们定义三个指针left、mid、right分别指向数组的最左边下标，中间下标和最右下标，通过比较numbers[mid]值与numbers[right]值来不断缩小区间
题解参考LeetCode链接
[https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/)
### 代码

```cpp
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int left = 0;
        int right = numbers.size() - 1;
        while(left < right)
        {
            int mid = (left + right) / 2;
            if(numbers[mid] > numbers[right])
                left = mid + 1;
            else if(numbers[mid] < numbers[right])
                right = mid;
            else
                right -= 1;
        }

        return numbers[left];
    }
};
```

# [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 

## 思路1：

首先定义一个map存储数组中的元素，没存储一个就将将该元素bool值置为true

1. 遍历数组中的元素并存入map中
2. 如果这个元素bool值为true说明重复，直接返回元素
3. 否则将该值存map中并置true

时间空间复杂度均为O(N)

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        unordered_map<int, bool> nMap;
        for(auto& n: nums)
        {
            if(nMap[n])
                return n;
            nMap[n] = true;
        }
        return -1;
    }
};
```

## 思路2：

原地置换

数组的下标用i表示

数组的第i个元素的值nums[i]

如果想让数组的第i个元素的值nums[i]在数组下标nums[i]的位置：nums[i] == nums[nums[i]]

1. 遍历数组nums
2. 如果数组如果数组nums的第i个数字的值nums[i]和数组下标刚好对应继续遍历
3. 如果数字在对应下标的位置说明重复直接返回
4. 都不是直接将数字交换对应下标的地方去

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        int i = 0;
        while(i < nums.size())
        {
            //1.数字在对应下标数组位置i++
            if(nums[i] == i)
            {
                i++;
                continue;
            }
            //2.数字在对应下标位置说明重复
            if(nums[i] == nums[nums[i]])
            {
                return nums[i];
            }
            std::swap(nums[i], nums[nums[i]]);
        }
        return -1;
    }
};
```

# [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

难度简单146

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

 

**示例：**

```
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
```

 

**提示：**

1. `0 <= nums.length <= 50000`
2. `1 <= nums[i] <= 10000`

## 思路1：左右双指针

快排思想，左边找偶数右边找奇数

```
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        while(left < right)
        {
            //左边找偶数，右边找奇数，然后交换
            while(left < right && (nums[left] % 2 == 1))
                left++;
            while((left < right) && (nums[right] % 2 == 0))
                right--;
            if(left < right)
                std::swap(nums[left], nums[right]);
        }
        return nums;
    }
};
```

## 思路2：前后快慢指针

```
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int prev = 0;
        int cur = 0;
        while(cur < nums.size())
        {
            if(nums[cur] % 2 == 1)
            {
                std::swap(nums[cur], nums[prev]);
                prev++;
            }
            cur++;
        }
        return nums;
    }
};
```

