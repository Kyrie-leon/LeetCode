# C++

## C++内存分配

栈

堆

全局/静态存储区

常量存储区

代码区

## 面向对象的三大特性，举例说明

- 封装

- 继承
- 多态

## 为什么构造函数不能为虚函数？

从实现来看，虚函数的调用需要虚函数表指针，而虚函数表指针需要构造函数实例化类对象，但是构造函数被声明为虚函数，对象还没有实例化出来，也没有内存空间，就不可能有虚函数表指针，所以不能为虚函数。

## 虚函数可以是static吗？

1. 不可以。static成员不属于任何类对象或类实例。所以加上virtual没有任何意义。

2. 静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。

虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.

对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual. 

虚函数的调用关系：this -> vptr -> vtable ->virtual function

## 为何static成员函数不能为const函数

当声明一个非静态成员函数为const时，对this指针会有影响。对于一个Test类中的const修饰的成员函数，this指针相当于const Test*, 而对于非const成员函数，this指针相当于Test *.

而static成员函数没有this指针，所以使用const来修饰static成员函数没有任何意义。

volatile的道理也是如此。

## define和const的区别？

define：预处理编译阶段进行的，没有类型，也没有类型检查，遇到宏定义就是字符串的展开，遇到多少次就展开多少次，没有分配内存，但会有多份数据的拷贝

const：编译期间处理的，有类型和类型检查，有内存，只保留一份数据的拷贝

## 模板的原理

模板可以分为函数模板和类模板。函数模板是**编译器根据传入的实参类型来推演生成对应类型的函数以供调用**。

类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟<>，然后将实例化的类型放在<>中即可，类模板名字不是真正的类，而实例化的结果才是真正的类。

编译器会对模板函数进行两次编译：在声明的地方进行编译，再调用的地方对参数替换后的代码进行编译。

## 预处理、编译、汇编、链接的过程

预处理

①将所有的“#define”删除，并且展开所有的宏定义

  ②处理所有的条件编译指令，如：“#if”、“#ifdef”、“#elif”、“#else”、“endif”等。这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。预编译程序将根据有关的文件，将那些不必要的代码过滤掉。 

  ③处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。

（注意：这个过程可能是递归进行的，也就是说被包含的文件可能还包含其他文件）

- **删除所有的注释**

- **添加行号和文件名标识。**

  以便于编译时编译器产生调试用的行号信息及用于编译时产生的编译错误或警告时能够显示行号

- **保留所有的#pragma编译器指令**

**2. 编译**

将预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后，产生相应的汇编代码文件。

**3. 汇编**

**将编译完的汇编代码文件翻译成机器指令，并生成可重定位目标程序的.o文件，该文件为二进制文件，字节编码是机器指令。**

汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译即可。

**4. 链接**

**通过链接器将一个个目标文件（或许还会有库文件）链接在一起生成一个完整的可执行程序。**

  由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。

例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。

  链接程序的主要工作就是将有关的目标文件彼此相连接，也就是将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。



## 动态编译与静态编译

静态编译，编译器在编译可执行文件时候把需要对应的动态链接库中的部分提取出来，连接到可执行文件中，不需要依赖动态链接库

动态编译：可执行文件需要附带一个动态链接库，执行时调用其动态链接库的命令，缩小了执行文件体积，加快了编译速度，节省了系统资源。缺点是一两条简单命令也要携带庞大的动态链接库，二是一旦计算机没有安装动态链接库执行文件不能运行。



## 在main函数前如何运行一段程序？

static初始化在程序初始阶段，先于main函数执行

```
int test()
{
	cout << "test" << endl;
	return 1;
}

static int i = test();

int main()
{}
```



# STL

### 1.迭代器的作用，和指针的区别？有了指针为什么用迭代器？

1. 迭代器模式是运用于聚合对象的一种模式，通过运用这种模式，在不知道内部对象表示的情况下，可以顺序访问对象中的各个元素。
2. 迭代器不是指针，是类模板，只是表现的像指针。其内部模式实现了指针的部分操作，通过重载->、*、++、--操作符。迭代器封装了指针，提供了比指针更高级的行为，可以根据不同的数据结构++、--等操作。
3. 迭代器是把不同集合类的访问逻辑抽象出来，是得不暴露集合内部结构达到循环遍历集合的结果

### 2. STL迭代器删除元素？迭代器失效问题

1. 对于序列容器vector,string来说，erase后后面的每个迭代器都会失效，但是会返回下一个有效的迭代器
2. 对于关联式容器map、set来说，erase后，只是当前元素的迭代器失效，不影响下一个元素的迭代器，通过保存下一个元素的迭代器即可
3. 对于list来说，erase也只删除当前元素迭代器，保存下一个元素迭代器即可

### 3. STL中resize和reserve区别

1. resize：指定生成size个元素，如果小于原来的元素数量补齐size个元素默认0
2. reserver：指定容量大小为size，不改变当前元素的个数。如果大于原来的容量会重新分配空间内存，拷贝赋值。



# TCP



