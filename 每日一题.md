# day11

## 1. 求最近的公共祖先

思路：

不难发现一个规律，a和b的祖先都是a或b/(除以)2，要么a和b有公共祖先，要么a是b的祖先或者b是a的祖先，这样很容易求解了。循环让最大的数字先除以2，因为有可能小的数字是大的数字的祖先，直到a和b相等就可以了

```c++
class LCA {
public:
    int getLCA(int a, int b) {
        // write code here
        while(a != b)
        {
            if(a > b)
                a /= 2;
            if(a < b)
                b /=2;
        }
        return b;
    }
};
```



## 2.求byte最大的连续数字1

思路：

1. 构建一个数组存放byte转化为2进值数字的每一位数字，然后定义一个计数器count，遍历这个数组并计数连续的1的个数

2. 直接使用位运算，让数字byte和1进行逻辑与运算，然后右移知道数字byte为0

   注意细节：牛客网的测试用例为循环输入，因此输入用例需要写一个while循环，切记切记切记！

```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

int MaxConNum(int n)
{
    int count = 0;
    int ret = 0;
    vector<int> nums;
    while(n)
    {
        nums.push_back(n%2);
        n /= 2;
    }
    
    for(auto num : nums)
    {
        if(num == 1)
        {
            count++;
            if(count > ret)
                ret = count;
        }
        else
        {
            count = 0;
        }
    }
    return ret;
}

int MaxConNum1(int n)
{
    int count = 0;
    int ret = 0;
    while(n)
    {
        if(n & 1)
        {
            ++count;
            if(count > ret)
                ret = count;
        }
        else
            count = 0;
        n >>= 1;
    }
    return ret;
}

int main()
{
    int n;
    while(cin >> n)
    {
        int ret = MaxConNum1(n);
        cout << ret << endl;
    }
    return 0;
}

```

